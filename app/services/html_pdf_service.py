"""HTML to PDF conversion service using CloudLayer.io API"""

import asyncio
import logging
from typing import Dict, Any, Optional
from datetime import datetime
import aiohttp
import base64
import json

from app.core.config import settings
from app.utils.exceptions import ServiceError

logger = logging.getLogger(__name__)


class HTMLPDFService:
    """Service for generating PDF reports from HTML using CloudLayer.io API"""
    
    def __init__(self):
        self.api_key = settings.CLOUDLAYER_API_KEY
        self.api_url = "https://api.cloudlayer.io"
        if not self.api_key:
            logger.warning("‚ö†Ô∏è CloudLayer.io API key not configured! Set CLOUDLAYER_API_KEY environment variable.")
    
    def reset_cloudlayer_check(self):
        """Reset CloudLayer availability check (for testing)"""
        pass
    
    async def _ensure_cloudlayer_available(self) -> bool:
        """Ensure CloudLayer.io API is available"""
        if not self.api_key:
            logger.error("‚ùå CloudLayer.io API key not configured!")
            return False
        
        try:
            logger.info("üîç Checking CloudLayer.io API availability...")
            
            async with aiohttp.ClientSession() as session:
                headers = {
                    'x-api-key': self.api_key,
                    'Content-Type': 'application/json'
                }
                
                # Test with minimal HTML (base64 encoded)
                test_html = '<html><body><h1>Test</h1></body></html>'
                test_html_b64 = base64.b64encode(test_html.encode('utf-8')).decode('utf-8')
                
                test_data = {
                    'html': test_html_b64
                }
                
                async with session.post(
                    f'{self.api_url}/v2/html/pdf',
                    headers=headers,
                    json=test_data,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    if response.status in [200, 202]:  # 202 = async processing
                        logger.info("‚úÖ CloudLayer.io API is available and working")
                        return True
                    else:
                        error_text = await response.text()
                        logger.error(f"‚ùå CloudLayer.io API test failed with status {response.status}: {error_text}")
                        return False
                        
        except Exception as e:
            logger.error(f"üí• CloudLayer.io API availability check failed: {e}")
            return False

    async def _wait_for_job_completion(self, session: aiohttp.ClientSession, job_id: str) -> str:
        """Wait for CloudLayer.io job completion and return download URL"""
        max_attempts = 30  # Max 30 attempts (30 seconds with 1 second delay)
        attempt = 0
        
        while attempt < max_attempts:
            try:
                headers = {'x-api-key': self.api_key}
                
                async with session.get(
                    f'{self.api_url}/v2/jobs/{job_id}',
                    headers=headers,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    
                    if response.status == 200:
                        job_data = await response.json()
                        status = job_data.get('status')
                        
                        if status in ['completed', 'success']:
                            # Log full response to understand structure
                            logger.debug(f"üìã CloudLayer.io job response: {job_data}")
                            
                            # First check for assetUrl specifically
                            download_url = job_data.get('assetUrl')
                            logger.debug(f"üîç Checking assetUrl: {download_url}")
                            
                            # If not found, try other fields
                            if not download_url:
                                download_url = job_data.get('url')
                                logger.debug(f"üîç Checking url: {download_url}")
                            
                            if not download_url:
                                download_url = job_data.get('download_url')
                                logger.debug(f"üîç Checking download_url: {download_url}")
                            
                            if not download_url:
                                download_url = job_data.get('file_url')
                                logger.debug(f"üîç Checking file_url: {download_url}")
                            
                            if download_url:
                                logger.info(f"‚úÖ CloudLayer.io job {job_id} completed successfully! URL: {download_url}")
                                return download_url
                            else:
                                logger.error(f"Job completed but no download URL found in response: {job_data}")
                                raise ServiceError(f"Job completed but no download URL provided")
                        
                        elif status == 'failed':
                            error_message = job_data.get('error', 'Unknown error')
                            raise ServiceError(f"CloudLayer.io job failed: {error_message}")
                        
                        elif status in ['processing', 'pending']:
                            logger.debug(f"üîÑ CloudLayer.io job {job_id} is {status}, waiting...")
                            await asyncio.sleep(1)
                            attempt += 1
                            continue
                        
                        else:
                            raise ServiceError(f"Unknown job status: {status}")
                    
                    else:
                        error_text = await response.text()
                        raise ServiceError(f"Failed to check job status: {response.status} - {error_text}")
                        
            except asyncio.TimeoutError:
                logger.warning(f"‚è∞ Timeout checking job {job_id} status, retrying...")
                await asyncio.sleep(1)
                attempt += 1
                continue
        
        raise ServiceError(f"Job {job_id} did not complete within {max_attempts} seconds")

    async def generate_partner_report_html(
        self,
        analysis_data: Dict[str, Any],
        user_id: int,
        partner_name: str
    ) -> bytes:
        """
        Generate professional partner analysis PDF report using CloudLayer.io API
        
        Args:
            analysis_data: Analysis results from AI
            user_id: User ID
            partner_name: Partner name
            
        Returns:
            PDF bytes
        """
        try:
            logger.info(f"Starting PROFESSIONAL PDF generation for user {user_id}, partner: {partner_name}")
            logger.debug(f"Analysis data keys: {list(analysis_data.keys())}")
            
            # Check CloudLayer.io availability
            logger.info("üîÑ Checking CloudLayer.io API availability...")
            cloudlayer_available = await self._ensure_cloudlayer_available()
            
            if not cloudlayer_available:
                logger.error("‚ùå CloudLayer.io API is required for professional PDF generation!")
                raise ServiceError("CloudLayer.io API is not available. Please check your API key and internet connection.")
            
            logger.info("‚úÖ Using CloudLayer.io for professional PDF generation")
            
            # Generate complete HTML report
            html_content = self._generate_beautiful_html_report(analysis_data, partner_name, user_id)
            
            # Convert HTML to PDF using CloudLayer.io
            pdf_bytes = await self._convert_html_to_pdf_cloudlayer(html_content)
            
            logger.info(f"‚úÖ Professional PDF generated successfully! Size: {len(pdf_bytes)} bytes")
            return pdf_bytes
            
        except Exception as e:
            logger.error(f"üí• Professional PDF generation failed: {e}")
            raise ServiceError(f"Failed to generate professional PDF: {str(e)}")

    async def _convert_html_to_pdf_cloudlayer(self, html_content: str) -> bytes:
        """Convert HTML to PDF using CloudLayer.io API"""
        try:
            logger.info("üîÑ Converting HTML to PDF using CloudLayer.io...")
            
            async with aiohttp.ClientSession() as session:
                headers = {
                    'x-api-key': self.api_key,
                    'Content-Type': 'application/json'
                }
                
                # Encode HTML to base64 as required by CloudLayer.io
                html_b64 = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')
                
                # CloudLayer.io API v2 payload
                payload = {
                    'html': html_b64,
                    'viewPort': {
                        'width': 1200,
                        'height': 800
                    },
                    'format': 'A4',
                    'landscape': False,
                    'printBackground': True,
                    'margin': {
                        'top': '0.5in',
                        'right': '0.5in',
                        'bottom': '0.5in',
                        'left': '0.5in'
                    },
                    'preferCSSPageSize': True
                }
                
                logger.debug(f"üì§ Sending request to CloudLayer.io API v2...")
                
                async with session.post(
                    f'{self.api_url}/v2/html/pdf',
                    headers=headers,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=60)
                ) as response:
                    
                    if response.status == 200:
                        # Synchronous response - PDF ready immediately
                        response_data = await response.json()
                        file_url = response_data.get('url')
                        
                        if file_url:
                            # Download PDF file
                            async with session.get(file_url) as file_response:
                                if file_response.status == 200:
                                    pdf_bytes = await file_response.read()
                                    logger.info(f"‚úÖ PDF generated successfully via CloudLayer.io! Size: {len(pdf_bytes)} bytes")
                                    return pdf_bytes
                                else:
                                    raise ServiceError(f"Failed to download PDF from CloudLayer.io CDN: {file_response.status}")
                        else:
                            raise ServiceError("CloudLayer.io response missing file URL")
                    
                    elif response.status == 202:
                        # Asynchronous response - need to wait for job completion
                        job_data = await response.json()
                        job_id = job_data.get('id')
                        
                        if not job_id:
                            raise ServiceError("CloudLayer.io did not return job ID")
                        
                        logger.info(f"üîÑ CloudLayer.io job {job_id} started, waiting for completion...")
                        
                        # Wait for job completion
                        download_url = await self._wait_for_job_completion(session, job_id)
                        
                        # Download the completed PDF
                        async with session.get(download_url) as file_response:
                            if file_response.status == 200:
                                pdf_bytes = await file_response.read()
                                logger.info(f"‚úÖ PDF generated successfully via CloudLayer.io! Size: {len(pdf_bytes)} bytes")
                                return pdf_bytes
                            else:
                                raise ServiceError(f"Failed to download PDF from CloudLayer.io CDN: {file_response.status}")
                    
                    else:
                        error_text = await response.text()
                        logger.error(f"‚ùå CloudLayer.io API error {response.status}: {error_text}")
                        raise ServiceError(f"CloudLayer.io API error {response.status}: {error_text}")
                        
        except aiohttp.ClientError as e:
            logger.error(f"‚ùå CloudLayer.io API request failed: {e}")
            raise ServiceError(f"CloudLayer.io API request failed: {str(e)}")
        except Exception as e:
            logger.error(f"üí• CloudLayer.io PDF conversion failed: {e}")
            raise ServiceError(f"Failed to convert HTML to PDF: {str(e)}")

    def _generate_beautiful_html_report(
        self,
        analysis_data: Dict[str, Any],
        partner_name: str,
        user_id: int = 123
    ) -> str:
        """Generate beautiful HTML report using Jinja2 template"""
        
        # Extract data safely
        overall_risk = self._extract_risk_score(analysis_data)
        red_flags = analysis_data.get('red_flags', [])
        recommendations = analysis_data.get('survival_guide', analysis_data.get('recommendations', []))
        psychological_profile = analysis_data.get('psychological_profile', '–ê–Ω–∞–ª–∏–∑ –ª–∏—á–Ω–æ—Å—Ç–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ª–æ–∂–Ω—ã–µ –ø–æ–≤–µ–¥–µ–Ω—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã')
        
        # Generate assessment details
        risk_level, risk_color, risk_badge_color = self._determine_risk_level(overall_risk)
        
        # Current date
        current_date = datetime.now().strftime("%d.%m.%Y")
        report_id = f"RPT-{datetime.now().strftime('%d%m%Y')}-{user_id:03d}"
        
        # Generate personality type based on risk
        personality_type = self._determine_personality_type(overall_risk)
        
        # Prepare template data
        template_data = {
            'partner_name': partner_name,
            'date': current_date,
            'report_id': report_id,
            'risk_score': int(overall_risk),
            'urgency': 'CRITICAL' if overall_risk > 70 else 'HIGH' if overall_risk > 40 else 'MEDIUM' if overall_risk > 20 else 'LOW',
            'personality_type': personality_type,
            'psychological_profile': psychological_profile,
            'red_flags': red_flags[:6] if len(red_flags) > 6 else red_flags,  # Limit to 6 for display
            'recommendations': '\n'.join(recommendations) if isinstance(recommendations, list) else str(recommendations),
            'population_percentile': min(95, int(overall_risk * 1.2)),  # Conservative estimate
            'blocks': self._generate_blocks_data(analysis_data, overall_risk),
            'charts': {
                'blocks_chart': None,  # Could be generated dynamically
                'dark_triad_chart': None,
                'risk_circle': None
            }
        }
        
        # Load and render template
        try:
            from jinja2 import Environment, FileSystemLoader
            import os
            
            # Get template directory
            template_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'templates', 'pdf')
            env = Environment(loader=FileSystemLoader(template_dir))
            template = env.get_template('partner_report.html')
            
            # Render template with data
            html_content = template.render(**template_data)
            logger.info("‚úÖ HTML template rendered successfully")
            return html_content
            
        except Exception as e:
            logger.error(f"Failed to render template: {e}")
            # Fallback to simple HTML if template fails
            return self._generate_simple_fallback_html(template_data)
    
    def _generate_blocks_data(self, analysis_data: Dict[str, Any], overall_risk: float) -> list:
        """Generate blocks data for template"""
        blocks = [
            {
                'name': '–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å',
                'emoji': 'üò†',
                'score': min(10, int(overall_risk / 10)),
                'level': '–ö–†–ò–¢–ò–ß–ù–û' if overall_risk > 70 else '–í–´–°–û–ö–û' if overall_risk > 40 else '–£–ú–ï–†–ï–ù–ù–û'
            },
            {
                'name': '–ú–∞–Ω–∏–ø—É–ª—è—Ç–∏–≤–Ω–æ—Å—Ç—å',
                'emoji': 'üé≠',
                'score': min(10, int((overall_risk + 10) / 12)),
                'level': '–ö–†–ò–¢–ò–ß–ù–û' if overall_risk > 70 else '–í–´–°–û–ö–û' if overall_risk > 40 else '–£–ú–ï–†–ï–ù–ù–û'
            },
            {
                'name': '–≠–º–ø–∞—Ç–∏—è',
                'emoji': 'üíù',
                'score': max(1, 10 - int(overall_risk / 10)),  # Inverse correlation
                'level': '–ù–ò–ó–ö–û' if overall_risk > 70 else '–£–ú–ï–†–ï–ù–ù–û' if overall_risk > 40 else '–ù–û–†–ú–ê–õ–¨–ù–û'
            },
            {
                'name': '–ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ—Å—Ç—å',
                'emoji': '‚ö°',
                'score': min(10, int(overall_risk / 8)),
                'level': '–ö–†–ò–¢–ò–ß–ù–û' if overall_risk > 70 else '–í–´–°–û–ö–û' if overall_risk > 40 else '–£–ú–ï–†–ï–ù–ù–û'
            }
        ]
        return blocks
    
    def _generate_simple_fallback_html(self, data: dict) -> str:
        """Simple fallback HTML if template fails"""
        return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>–ü—Ä–æ—Ñ–∏–ª—å –ø–∞—Ä—Ç–Ω–µ—Ä–∞ - {data['partner_name']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; padding: 20px; }}
        .header {{ background: #667eea; color: white; padding: 20px; text-align: center; }}
        .risk-score {{ font-size: 48px; color: red; text-align: center; margin: 20px; }}
        .section {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>–ü–°–ò–•–û–õ–û–ì–ò–ß–ï–°–ö–ò–ô –ü–†–û–§–ò–õ–¨ –ü–ê–†–¢–ù–ï–†–ê</h1>
        <p>–ü–∞—Ä—Ç–Ω–µ—Ä: {data['partner_name']} | –î–∞—Ç–∞: {data['date']}</p>
            </div>
            
    <div class="risk-score">–û—Ü–µ–Ω–∫–∞ —Ä–∏—Å–∫–∞: {data['risk_score']}</div>
            
            <div class="section">
        <h3>–¢–∏–ø –ª–∏—á–Ω–æ—Å—Ç–∏</h3>
        <p>{data['personality_type']}</p>
            </div>
            
            <div class="section">
        <h3>–ö—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏</h3>
        <ul>{''.join(f'<li>{flag}</li>' for flag in data['red_flags'])}</ul>
            </div>
            
            <div class="section">
        <h3>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏</h3>
        <p>{data['recommendations']}</p>
    </div>
</body>
</html>"""
    
    def _generate_red_flags_html(self, red_flags: list) -> str:
        """Generate HTML for red flags section"""
        if not red_flags:
            return '<div class="red-flag">–ö—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</div>'
        
        html_parts = []
        for flag in red_flags:
            html_parts.append(f'<div class="red-flag">‚Ä¢ {flag}</div>')
        
        return '\\n'.join(html_parts)
    
    def _generate_recommendations_html(self, recommendations: list) -> str:
        """Generate HTML for recommendations section"""
        if not recommendations:
            return '<div class="recommendation">–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è</div>'
        
        html_parts = []
        for rec in recommendations:
            html_parts.append(f'<div class="recommendation">‚Ä¢ {rec}</div>')
        
        return '\\n'.join(html_parts)
    
    def _extract_risk_score(self, analysis_data: Dict[str, Any]) -> float:
        """Extract risk score from analysis data"""
        # Try different field names
        for field in ['overall_risk_score', 'manipulation_risk', 'risk_score', 'toxicity_score']:
            if field in analysis_data:
                value = analysis_data[field]
                if isinstance(value, (int, float)):
                    # Convert to percentage if needed
                    if field == 'manipulation_risk' and value <= 10:
                        return value * 10  # Convert 0-10 scale to 0-100
                    return min(value, 100)
        
        # Default if no risk score found
        return 50.0
    
    def _determine_risk_level(self, risk_score: float) -> tuple:
        """Determine risk level text and colors"""
        if risk_score >= 80:
            return "–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –†–ò–°–ö", "#dc3545", "#dc3545"
        elif risk_score >= 60:
            return "–í–´–°–û–ö–ò–ô –†–ò–°–ö", "#fd7e14", "#fd7e14"
        elif risk_score >= 40:
            return "–°–†–ï–î–ù–ò–ô –†–ò–°–ö", "#ffc107", "#ffc107"
        else:
            return "–ù–ò–ó–ö–ò–ô –†–ò–°–ö", "#28a745", "#28a745"
    
    def _determine_personality_type(self, risk_score: float) -> str:
        """Determine personality type based on risk score"""
        if risk_score >= 80:
            return "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ç–æ–∫—Å–∏—á–Ω—ã–π –Ω–∞—Ä—Ü–∏—Å—Å"
        elif risk_score >= 70:
            return "–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–∏–π –Ω–∞—Ä—Ü–∏—Å—Å"
        elif risk_score >= 60:
            return "–ú–∞–Ω–∏–ø—É–ª—è—Ç–∏–≤–Ω–∞—è –ª–∏—á–Ω–æ—Å—Ç—å"
        elif risk_score >= 40:
            return "–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã–π"
        else:
            return "–£—Å–ª–æ–≤–Ω–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–π"
    
    def _get_personality_description(self, personality_type: str) -> str:
        """Get description for personality type"""
        descriptions = {
            "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Ç–æ–∫—Å–∏—á–Ω—ã–π –Ω–∞—Ä—Ü–∏—Å—Å": "–ö—Ä–∞–π–Ω–µ –æ–ø–∞—Å–Ω–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –Ω–∞—Ä—Ü–∏—Å—Å–∏—á–µ—Å–∫–∏—Ö —á–µ—Ä—Ç —Å —Å–∞–¥–∏—Å—Ç—Å–∫–∏–º–∏ –Ω–∞–∫–ª–æ–Ω–Ω–æ—Å—Ç—è–º–∏ –∏ –ø–æ–ª–Ω—ã–º –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ–º —ç–º–ø–∞—Ç–∏–∏",
            "–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–∏–π –Ω–∞—Ä—Ü–∏—Å—Å": "–í—ã—Ä–∞–∂–µ–Ω–Ω—ã–µ –Ω–∞—Ä—Ü–∏—Å—Å–∏—á–µ—Å–∫–∏–µ —á–µ—Ä—Ç—ã —Å –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å—é –≤ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏ –∏ –∫–æ–Ω—Ç—Ä–æ–ª–µ –Ω–∞–¥ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–º",
            "–ú–∞–Ω–∏–ø—É–ª—è—Ç–∏–≤–Ω–∞—è –ª–∏—á–Ω–æ—Å—Ç—å": "–°–∫–ª–æ–Ω–Ω–æ—Å—Ç—å –∫ —Å–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –º–∞–Ω–∏–ø—É–ª—è—Ü–∏—è–º –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º—É –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—é",
            "–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã–π": "–ù–µ–ø—Ä–µ–¥—Å–∫–∞–∑–∏–º—ã–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏ —Å —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è",
            "–£—Å–ª–æ–≤–Ω–æ —Å—Ç–∞–±–∏–ª—å–Ω—ã–π": "–í —Ü–µ–ª–æ–º —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –ª–∏—á–Ω–æ—Å—Ç—å —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ –ø—Ä–æ–±–ª–µ–º–Ω—ã–º–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º–∏ –ø–æ–≤–µ–¥–µ–Ω–∏—è"
        }
        return descriptions.get(personality_type, "–ê–Ω–∞–ª–∏–∑ –ª–∏—á–Ω–æ—Å—Ç–Ω—ã—Ö –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π")
    
    def _generate_key_traits(self, analysis_data: Dict[str, Any], risk_score: float) -> str:
        """Generate key traits HTML list"""
        if risk_score >= 70:
            traits = [
                "üî¥ –°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å –ø–æ–≤–µ–¥–µ–Ω–∏—è",
                "üî¥ –ì–∞–∑–ª–∞–π—Ç–∏–Ω–≥ –∏ –∏—Å–∫–∞–∂–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏", 
                "üî¥ –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –Ω–∞—Å–∏–ª–∏–µ",
                "üî¥ –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —ç–º–ø–∞—Ç–∏–∏"
            ]
        elif risk_score >= 50:
            traits = [
                "üü° –≠–ª–µ–º–µ–Ω—Ç—ã –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è",
                "üü° –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å",
                "üü° –ü—Ä–æ–±–ª–µ–º—ã —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏",
                "üü° –°–∫–ª–æ–Ω–Ω–æ—Å—Ç—å –∫ –º–∞–Ω–∏–ø—É–ª—è—Ü–∏—è–º"
            ]
        else:
            traits = [
                "üü¢ –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã",
                "üü° –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏",
                "üü° –ö–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–æ–Ω–Ω—ã–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏",
                "üü¢ –í —Ü–µ–ª–æ–º –∞–¥–µ–∫–≤–∞—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ"
            ]
        
        return '\n'.join([f'<li>{trait}</li>' for trait in traits])
    
    def _generate_detailed_red_flags(self, red_flags: list, risk_score: float) -> str:
        """Generate detailed red flags HTML"""
        if not red_flags or len(red_flags) == 0:
            # Generate default red flags based on risk score
            if risk_score >= 70:
                red_flags = [
                    ("–°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Ç—Ä–æ–ª—å –ø–æ–≤–µ–¥–µ–Ω–∏—è", "–ü–∞—Ä—Ç–Ω–µ—Ä –ø—ã—Ç–∞–µ—Ç—Å—è –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, –æ–±—â–µ–Ω–∏–µ —Å –¥—Ä—É–∑—å—è–º–∏ –∏ –ø—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏–π"),
                    ("–ì–∞–∑–ª–∞–π—Ç–∏–Ω–≥ –∏ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏", "–û—Ç—Ä–∏—Ü–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–æ—à–µ–¥—à–∏—Ö —Å–æ–±—ã—Ç–∏–π, –æ–±–µ—Å—Ü–µ–Ω–∏–≤–∞–Ω–∏–µ –≤–∞—à–∏—Ö –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π –∏ —á—É–≤—Å—Ç–≤"),
                    ("–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —à–∞–Ω—Ç–∞–∂", "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —á—É–≤—Å—Ç–≤–∞ –≤–∏–Ω—ã –∏ –ª—é–±–≤–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∂–µ–ª–∞–µ–º–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è"),
                    ("–ò–∑–æ–ª—è—Ü–∏—è –æ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏", "–ü–æ–ø—ã—Ç–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –≤–∞—à–µ –æ–±—â–µ–Ω–∏–µ —Å —Å–µ–º—å–µ–π, –¥—Ä—É–∑—å—è–º–∏ –∏ –¥—Ä—É–≥–∏–º–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏")
                ]
            elif risk_score >= 50:
                red_flags = [
                    ("–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–∏–µ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏", "–ü–æ–ø—ã—Ç–∫–∏ –≤–ª–∏—è—Ç—å –Ω–∞ –≤–∞—à–∏ —Ä–µ—à–µ–Ω–∏—è –∏ –≤—ã–±–æ—Ä—ã"),
                    ("–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ", "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —ç–º–æ—Ü–∏–π –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∂–µ–ª–∞–µ–º–æ–≥–æ"),
                    ("–ù–∞—Ä—É—à–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü", "–ù–µ—É–≤–∞–∂–µ–Ω–∏–µ –∫ –≤–∞—à–∏–º –ª–∏—á–Ω—ã–º –≥—Ä–∞–Ω–∏—Ü–∞–º –∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤—É")
                ]
            else:
                red_flags = [
                    ("–ö–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã", "–°–ª–æ–∂–Ω–æ—Å—Ç–∏ –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –∏ —á–µ—Å—Ç–Ω–æ–º –æ–±—â–µ–Ω–∏–∏"),
                    ("–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏", "–ù–µ–ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –Ω–∞ —Å–∏—Ç—É–∞—Ü–∏–∏")
                ]
        else:
            # Convert simple list to tuples with descriptions
            red_flags = [(flag, f"–ê–Ω–∞–ª–∏–∑ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞–ª–∏—á–∏–µ –¥–∞–Ω–Ω–æ–≥–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è: {flag.lower()}") for flag in red_flags[:4]]
        
        html_parts = []
        for title, description in red_flags:
            html_parts.append(f'''
                <div class="red-flag">
                    <div class="red-flag-title">{title}</div>
                    <p>{description}</p>
                </div>
            ''')
        
        return '\n'.join(html_parts)
    
    def _generate_protection_strategies(self, recommendations: list) -> str:
        """Generate protection strategies HTML"""
        strategies = [
            "<strong>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ç–∫–∏—Ö –≥—Ä–∞–Ω–∏—Ü:</strong> –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –Ω–µ–ø—Ä–∏–µ–º–ª–µ–º–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∏ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –∑–∞ –µ–≥–æ –Ω–∞—Ä—É—à–µ–Ω–∏–µ",
            "<strong>–¢–µ—Ö–Ω–∏–∫–∞ \"–°–µ—Ä—ã–π –∫–∞–º–µ–Ω—å\":</strong> –ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–π—Ç–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏, –æ—Ç–≤–µ—á–∞–π—Ç–µ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ –∏ –∫—Ä–∞—Ç–∫–æ",
            "<strong>–î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–æ–≤:</strong> –í–µ–¥–∏—Ç–µ –¥–Ω–µ–≤–Ω–∏–∫ —Å–ª—É—á–∞–µ–≤ –ø—Ä–æ–±–ª–µ–º–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è —Å –¥–∞—Ç–∞–º–∏ –∏ –¥–µ—Ç–∞–ª—è–º–∏",
            "<strong>–ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ —Å–≤—è–∑–µ–π:</strong> –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∏ —É–∫—Ä–µ–ø–∏—Ç–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å —Å–µ–º—å–µ–π –∏ –¥—Ä—É–∑—å—è–º–∏"
        ]
        
        if recommendations:
            # Add custom recommendations
            for rec in recommendations[:2]:
                strategies.append(f"<strong>–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:</strong> {rec}")
        
        return '\n'.join([f'<li>{strategy}</li>' for strategy in strategies])
    
    def _generate_action_plan(self, risk_score: float) -> str:
        """Generate action plan HTML"""
        if risk_score >= 70:
            urgency = "–Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã—Ö"
            short_term = [
                "–ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –ø—Å–∏—Ö–æ–ª–æ–≥—É –¥–ª—è –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏",
                "–°–æ–∑–¥–∞—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –¥–ª—è —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π —Å–≤—è–∑–∏",
                "–ù–∞—á–∞—Ç—å –≤–µ–¥–µ–Ω–∏–µ –¥–Ω–µ–≤–Ω–∏–∫–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π",
                "–ò–∑—É—á–∏—Ç—å —Ç–µ—Ö–Ω–∏–∫–∏ –∑–∞—â–∏—Ç—ã –æ—Ç –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π",
                "–†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Ä–µ–º–µ–Ω–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –º–µ—Å—Ç–∞ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è"
            ]
        elif risk_score >= 50:
            urgency = "—Å–∫–æ—Ä–µ–π—à–∏—Ö"
            short_term = [
                "–û–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –ø—Å–∏—Ö–æ–ª–æ–≥—É –¥–ª—è –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏",
                "–°–æ–∑–¥–∞—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏—Ö –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤",
                "–ù–∞—á–∞—Ç—å –≤–µ–¥–µ–Ω–∏–µ –¥–Ω–µ–≤–Ω–∏–∫–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π",
                "–ò–∑—É—á–∏—Ç—å —Ç–µ—Ö–Ω–∏–∫–∏ –∑–∞—â–∏—Ç—ã –æ—Ç –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–π"
            ]
        else:
            urgency = "–ø–ª–∞–Ω–æ–º–µ—Ä–Ω—ã—Ö"
            short_term = [
                "–†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–∞—Ä–Ω–æ–π —Ç–µ—Ä–∞–ø–∏–∏",
                "–†–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –Ω–∞–≤—ã–∫–∞–º–∏ –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏",
                "–ò–∑—É—á–∏—Ç—å –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä—É –ø–æ –∑–¥–æ—Ä–æ–≤—ã–º –æ—Ç–Ω–æ—à–µ–Ω–∏—è–º"
            ]
        
        return f'''
            <h4 style="color: #667eea; margin-bottom: 15px;">–ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (1-2 –Ω–µ–¥–µ–ª–∏):</h4>
            <ul style="margin-left: 20px; margin-bottom: 25px;">
                {''.join([f'<li>{action}</li>' for action in short_term])}
            </ul>
            
            <h4 style="color: #667eea; margin-bottom: 15px;">–°—Ä–µ–¥–Ω–µ—Å—Ä–æ—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (1-3 –º–µ—Å—è—Ü–∞):</h4>
            <ul style="margin-left: 20px; margin-bottom: 25px;">
                <li>–†–∞–∑–≤–∏–≤–∞—Ç—å –Ω–∞–≤—ã–∫–∏ –∞—Å—Å–µ—Ä—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≥—Ä–∞–Ω–∏—Ü</li>
                <li>–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∏ –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â—É—é —Å–µ—Ç—å</li>
                <li>–†–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –ø–æ–≤—ã—à–µ–Ω–∏–µ–º —Å–∞–º–æ–æ—Ü–µ–Ω–∫–∏ –∏ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏</li>
                <li>–†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è –∂–∏–∑–Ω–µ–Ω–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏</li>
            </ul>
            
            <h4 style="color: #667eea; margin-bottom: 15px;">–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–µ —Ü–µ–ª–∏ (3+ –º–µ—Å—è—Ü–∞):</h4>
            <ul style="margin-left: 20px;">
                <li>–ü—Ä–∏–Ω—è—Ç—å –æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –æ –±—É–¥—É—â–µ–º –æ—Ç–Ω–æ—à–µ–Ω–∏–π</li>
                <li>–†–∞–∑–≤–∏—Ç—å —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –∫ –º–∞–Ω–∏–ø—É–ª—è—Ç–∏–≤–Ω–æ–º—É –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—é</li>
                <li>–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Å–∏—Ö–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–µ –±–ª–∞–≥–æ–ø–æ–ª—É—á–∏–µ</li>
                <li>–°–æ–∑–¥–∞—Ç—å –∑–¥–æ—Ä–æ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤–∑–∞–∏–º–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–π</li>
            </ul>
        '''
    
    def _get_level_description(self, score: float) -> str:
        """Get level description for score"""
        if score >= 8:
            return "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —É—Ä–æ–≤–µ–Ω—å"
        elif score >= 6:
            return "–í—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å"
        elif score >= 4:
            return "–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å"
        else:
            return "–ù–∏–∑–∫–∏–π —É—Ä–æ–≤–µ–Ω—å"
    
    def _generate_personality_characteristics(self, risk_score: float) -> str:
        """Generate personality characteristics HTML"""
        if risk_score >= 70:
            characteristics = [
                "–ì—Ä–∞–Ω–¥–∏–æ–∑–Ω–æ–µ —Å–∞–º–æ–≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ –∏ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å –≤ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–º –≤–æ—Å—Ö–∏—â–µ–Ω–∏–∏",
                "–ü–æ–ª–Ω–æ–µ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —ç–º–ø–∞—Ç–∏–∏ –∫ –ø–µ—Ä–µ–∂–∏–≤–∞–Ω–∏—è–º –ø–∞—Ä—Ç–Ω–µ—Ä–∞",
                "–°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–∞–Ω–∏–ø—É–ª—è—Ç–∏–≤–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–µ–π",
                "–ö–∞—Ç–µ–≥–æ—Ä–∏—á–µ—Å–∫–∞—è –Ω–µ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∫—Ä–∏—Ç–∏–∫—É –∏ –ø—Ä–∏–∑–Ω–∞–≤–∞—Ç—å –æ—à–∏–±–∫–∏",
                "–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å —Å –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–º–∏ –≤—Å–ø—ã—à–∫–∞–º–∏",
                "–ü–∞—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å –≤ –∫–æ–Ω—Ç—Ä–æ–ª–µ –Ω–∞–¥ –ø–∞—Ä—Ç–Ω–µ—Ä–æ–º"
            ]
        elif risk_score >= 50:
            characteristics = [
                "–ü–æ–≤—ã—à–µ–Ω–Ω–æ–µ —Å–∞–º–æ–≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ –∏ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å –≤ –æ–¥–æ–±—Ä–µ–Ω–∏–∏",
                "–û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è —ç–º–ø–∞—Ç–∏—è –∫ –ø–µ—Ä–µ–∂–∏–≤–∞–Ω–∏—è–º –ø–∞—Ä—Ç–Ω–µ—Ä–∞",
                "–°–∫–ª–æ–Ω–Ω–æ—Å—Ç—å –∫ –º–∞–Ω–∏–ø—É–ª—è—Ç–∏–≤–Ω–æ–º—É –ø–æ–≤–µ–¥–µ–Ω–∏—é",
                "–°–ª–æ–∂–Ω–æ—Å—Ç–∏ —Å –ø—Ä–∏–Ω—è—Ç–∏–µ–º –∫—Ä–∏—Ç–∏–∫–∏",
                "–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å",
                "–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—â–∏–µ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏"
            ]
        else:
            characteristics = [
                "–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ä—Ü–∏—Å—Å–∏—á–µ—Å–∫–∏–µ —á–µ—Ä—Ç—ã",
                "–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã —Å —ç–º–ø–∞—Ç–∏–µ–π",
                "–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —Å—Ç—Ä–µ—Å—Å",
                "–°–ª–æ–∂–Ω–æ—Å—Ç–∏ –≤ –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏"
            ]
        
        return '\n'.join([f'<li>{char}</li>' for char in characteristics])
    
    def _generate_behavior_patterns(self, risk_score: float) -> str:
        """Generate behavior patterns HTML"""
        if risk_score >= 70:
            patterns = [
                "–¶–∏–∫–ª \"–ª—é–±–æ–≤–Ω—ã–µ –±–æ–º–±–∞—Ä–¥–∏—Ä–æ–≤–∫–∏\" ‚Üí –æ–±–µ—Å—Ü–µ–Ω–∏–≤–∞–Ω–∏–µ ‚Üí –∫–æ–Ω—Ç—Ä–æ–ª—å",
                "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–ª—á–∞–Ω–∏—è –∫–∞–∫ —Ñ–æ—Ä–º—ã –ø—Å–∏—Ö–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –Ω–∞–∫–∞–∑–∞–Ω–∏—è",
                "–°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–æ–≤ –Ω–∞ –ø–∞—Ä—Ç–Ω–µ—Ä–∞",
                "–î–≤–æ–π–Ω—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª –∏ –æ–∂–∏–¥–∞–Ω–∏–π",
                "–≠—Å–∫–∞–ª–∞—Ü–∏—è –∞–≥—Ä–µ—Å—Å–∏–∏ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–∞—Ö —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã"
            ]
        elif risk_score >= 50:
            patterns = [
                "–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ —Ü–∏–∫–ª—ã –±–ª–∏–∑–æ—Å—Ç–∏ –∏ –æ—Ç–¥–∞–ª–µ–Ω–∏—è",
                "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —ç–º–æ—Ü–∏–π –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è —Å–∏—Ç—É–∞—Ü–∏–∏",
                "–ü—Ä–æ–µ–∫—Ü–∏—è –≤–∏–Ω—ã –Ω–∞ –ø–∞—Ä—Ç–Ω–µ—Ä–∞",
                "–ù–µ–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –ø–æ–≤–µ–¥–µ–Ω–∏–∏ –∏ –æ–±–µ—â–∞–Ω–∏—è—Ö"
            ]
        else:
            patterns = [
                "–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã",
                "–°–ª–æ–∂–Ω–æ—Å—Ç–∏ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ —á—É–≤—Å—Ç–≤",
                "–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã"
            ]
        
        return '\n'.join([f'<li>{pattern}</li>' for pattern in patterns]) 